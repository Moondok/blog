[{"content":"0. 说明 该系列小结为我在2023年秋修读同济大学操作系统课程的笔记，我校的操作系统课程主要以Unix v6 为范例进行剖析，因此以下的所有内容只适用于Unix v6 操作系统内核。另外，我校操作系统课程组对于Unix v6 操作系统的原始代码进行了面向对象的重构，下面给出的所有代码均为重构过后的代码片段。\n1. fork 1.1 fork系统调用简介与范例 fork 是一个系统调用，其主要功用为创建一个和当前进程 完全相同 的进程，新创建的进程为当前进程的子进程，二者的可交换部分完全相同，但彼此隔离，互不干扰，代码段共享。fork 的返回值是新创建的子进程的pid。\n下面是一个在用户态下调用fork 系统调用的代码示例片段。\nint a=0; main( ) { int i ; while( ( i=fork( ) ) == -1 ); if(i) { a = a+1; printf(“parent : a = %d\\n”, \u0026amp;a); } else { a=a+4; printf(“child : a = %d\\n”, \u0026amp;a); } } 在上面的代码段中，我们首先通过fork 创建了一个子进程，其pid 存储在i 变量中。在fork 系统调用成功创建新进程并准备返回时（系统调用入口程序SystemCallEntrance函数），系统执行例行调度。此时，新创建的子进程和原进程都可能被调度上台，具体情况由0号进程决定。\n假如原进程被先调度上台，则由于子进程创建成功，pid 势必不为0，进入if 分支，将a 的值改为1 ,并执行打印。在这之后原进程结束，子进程上台，进入else 分支，将a 的值改为4 （注意 ：子进程和父进程的数据段相互隔离，因此子进程中a的值仍为0），并进行打印，应用程序的输出为：\nparent : a=1 child : a=4 假如子进程被先调度上台，则进入else 分支，修改a 的值后打印。子进程结束后父进程被调度上台，进入if 分支后修改a 的值后执行打印，因此应用程序的输出为 :\nchild : a=4 parent : a=1 问题： 看到这里大家想必会有一个疑问，为什么子进程上台之后会进入else 分支执行呢？\n这是一个比较复杂的问题，我们需要读一读代码才能说清楚这件事。\n1.2 fork 系统调用代码解释 用户态下执行fork 系统调用的钩子函数如下\nint fork() { int res; __asm__ __volatile__ ( \u0026quot;int $0x80\u0026quot;:\u0026quot;=a\u0026quot;(res):\u0026quot;a\u0026quot;(2)); // 2#系统调用 if ( res \u0026gt;= 0 ) return res; return -1; } 这段代码很好理解，即使用int 0x80 指令让系统陷入内核后执行2号系统调用fork。\nfork 系统调用的函数如下\nint SystemCall::Sys_Fork() { ProcessManager\u0026amp; procMgr = Kernel::Instance().GetProcessManager(); procMgr.Fork(); return 0; /* GCC likes it ! */ } 可以看到在系统调用函数中，我们获取了内核的ProcessManager 对象，并执行其Fork 方法，接下来我们我们进入Fork函数内部去看看。\nvoid ProcessManager::Fork() { User\u0026amp; u = Kernel::Instance().GetUser(); Process* child = NULL;; /* 为子进程分配空闲的 process 项 */ for ( int i = 0; i \u0026lt; ProcessManager::NPROC; i++ ) { if ( this-\u0026gt;process[i].p_stat == Process::SNULL ) { child = \u0026amp;this-\u0026gt;process[i]; break; } } if ( child == NULL ) { /* 没有空闲 process 表项，返回 */ u.u_error = User::EAGAIN; return; } /* 调用 Newproc( )创建子进程，复制父进程图像 */ L： if ( this-\u0026gt;NewProc() ) { /* 新建子进程被 Swtch( )选中上台运行， *执行 Swtch( )函数逻辑，返回值是 1 *运行于 Newproc( )栈帧，返回地址是 if 语句。*/ u.u_ar0[User::EAX] = 0; // 子进程 fork()系统调用返回 0 u.u_cstime = 0; // 清 0 子进程的时间统计量 u.u_stime = 0; u.u_cutime = 0; u.u_utime = 0; } else { /* 子进程图像创建完毕后，父进程 Newproc( )返回 0 */ u.u_ar0[User::EAX] = child-\u0026gt;p_pid; // 父进程 fork()系统调用的返回值是子进程的 pid } return; } 在这个函数中，我们首先在process 表中查看有无空闲的表项，接着调用NewProc 函数。NewProc 函数的代码段很长，在此就不给出了，其主要功用是将父进程的可交换部分复制给子进程，且将子进程User 结构中的相对表指针u_MemoryDescriptor.m_UserPageTableArray 指向子进程的相对表。在完成了上述工作后，NewProc函数返回0。\n我们先停一下理一理头绪，现在我们的子进程已经创建起来了，其核心栈中栈顶处的几个栈帧分别为NewProc, Fork 和Sys_Fork ，子进程User 结构中的u_srav 中存储的esp和ebp 指针分别指向的是核心栈顶的NewProc栈帧的顶和底。\n当父进程的NewProc 返回时，其返回L 标签处的else 分支执行（NewProc的返回值为0），将新创建的子进程的pid存储在父进程核心栈中EAX 寄存器对应的区域以便我们在系统调用返回时能将返回值（即为子进程pid ）带入EAX 寄存器中。\n接下来Fork 函数返回，Sys_Fork 系统调用返回，在系统调用入口程序下半段执行例行调度Swtch 函数。\n假如此时被调度上台的还是父进程，则父进程通过自己的User 结构中的u_srav 找到Swtch 栈帧，执行Swtch的后半段后将其栈帧撤销，在这之后，返回系统调用入口程序的后半部分执行，回到用户态，非常合理顺畅。\n假如此时被调度上台的是我们新创建的子进程，则同样可以根据子进程的User 结构中的u_srav 找到\u0026hellip; 慢着！子进程核心栈中有Swtch吗，没有啊！子进程是被父进程创建出来的，其从来就没执行过，上哪去找Swtch 栈帧？\n好，知道了这一点，让我们看看接下来会发生什么。尽管子进程中没有Swtch 栈帧，但Swtch 下半段还是要走，我们将Swtch 的返回值 1 熟练地放进EAX 寄存器中，然后撤销核心栈中栈顶的那个栈帧，对应的汇编代码如下\nmov $1 %eax mox %ebp %esp pop %ebp ret 那么此时我们撤销的栈帧是哪个倒霉蛋的呢？没错，就是NewProc 函数的栈帧！（这一点在上面提到过）换句话说，我们把NewProc 的栈帧当作Swtch 栈帧撤销掉了，并把Swtch的返回值1 当作NewProc 的返回值放入了EAX 寄存器中，在这之后返回了Fork函数。\nFork 函数一看，嗯? 返回值是1？好好好，那么进入L 标签的if 标签执行，在这其中将0存储在父进程核心栈中EAX 寄存器对应的区域。接下来Fork返回，Sys_Fork系统调用返回，恢复系统调用现场。用户态程序从EAX 寄存器中拿到fork 的返回值0, 随即进入到else 分支中。\nif(i) #这里拿到的值为0 { ... } else #子进程进入这里执行！ { a=a+4; printf(“child : a = %d\\n”, \u0026amp;a); } 到这里，fork 系统调用大概就说完了，这其中我花了大段的篇幅解释了1.1 小节末尾处的那个问题，略过了很多细节，比如NewProc函数中父进程的可交换部分复制给子进程的过程，以及子进程的User结构中指向相对地址映射表的指针的获取过程等等。这些内容较为细碎，但理解难度不大，因此在此不再赘述。\n","permalink":"https://Moondok.github.io/blogs/posts/tech/os_process_manage_fork_exit_wait/","summary":"","title":"操作系统笔记-进程管理-创建与退出"},{"content":"写在前面 我本来以为我的第一篇博客是一篇正经的技术文档，没想到是出去玩\u0026hellip; Anyway, 鉴于我在上学期（2023年上半年）就看到了浦东美术馆关于这个展览的宣传，到现在只有一个月就闭展了，故决定这周末进一趟城（2023-10-22）。\n相亲角 为什么我先去了相亲角呢，是这样的。\n由于我觉得浦东美术馆不足以逛一天，所以我决定先去上海历史博物馆逛上几个小时；又因为上海历史博物馆就在人民公园正门的旁边，其入口处就是相亲角\u0026hellip; 嗯，很合理对吧。\n相亲角的阿姨爷叔很多，每个人面前摆着一张类似于简历的介绍单，上面大概写着子女的年龄，工作，薪资，家庭条件等等等等。或许是因为疫情，也可能是我上次来得太早了，相比于上次来（21年秋），这次很明显感觉公园门口的来为子女相亲的人变多了。\n根据我的观察，相亲的主力人群（指介绍单上面的子女们，来的大多是家长, or 媒人？）大部分集中于85年-95年这个年龄段，偶有70后和95后。大片大片的985（这里吐槽一句，看到很多你济的学长\u0026hellip;) 和海归，甚至还有外国人，我直呼国际化。\n其中令我比较深刻的介绍单是一个大约30岁左右的男同胞的，和一般的介绍信不太一样，里面有一栏写的是\n无正式感情经历 阿哲，当时我的嘴角流露出一丝不易察觉，但又有点难绷的微笑，但我收住了，没有笑出来。这当然不是因为我受过专业的训练，而是我突然想到，我到了他这个年纪，估计也是这种情况（恼 \u0026hellip;\n当我正准备走出公园的时候，一个阿姨叫住了我\n小伙子，你几几年的？ 我当时愣了一下，但还是实话实讲了（这有什么不能说的？\n还好阿姨没有问出什么让我难堪的问题（还是好人多啊 ， 而是转头对旁边另一个阿姨说\n你看，我就说他还挺小的 之后我就遁出了人民公园。\n就目前而言，对于把谈恋爱结婚这种事直接简化变成硬件条件匹配的行为，我总是觉得哪里怪怪的，即使能”匹配成功“，对于其稳健性和可持久性也深表怀疑。但随着我挨社会皮鞭挨得越来越多，自己指不定过几年也要流入到这种”market“里面接受他人凌厉目光的审讯，想必总有一天，我会理解这些家长们的。\n上海历史博物馆 好！终于要步入本文的正题之一了。\n上海历史博物馆我路过过很多次了，在逛外滩/南京路，上海博物馆，大世界等多次的行程中都从曾其门口经过。但每次不是因疫情不开放，便是我忘记将其添加到自己的行程中，导致一次也没有进去参观过。\n上海历史博物馆最显著的特征便是其高耸的西式钟楼。\n这也让我在本此参观之前产生了不必要的错觉：\n一座钟楼嘛，看样子不是很大，估计一两个小时足够了 进去我才知道，这栋建筑的前身是旧上海的跑马总会，这高耸的钟楼，不过是其建筑的一个侧边缘而已\u0026hellip; ,对其馆藏丰富量的错误估计导致我今天并没有完整细致地逛完这座博物馆，下次一定！\n前厅 博物馆的一层大厅是一个花轿，如下图\n根据介绍，这是一位20世纪初浙江商人请十余位木雕匠人历时10年制作的，结婚所用的花轿，需8个人抬。其上饰品为朱金漆木雕、琉璃画等。根据讲解员的介绍，木雕是分部分组装而成的，再于其上镶上金银纹饰；而琉璃画的制作，则需要匠人在背面作画（比如面向观众的一面琉璃画需匠人在其背面绘制）。\n上海古代史 史前 上海地区的古代历史可以追溯到公元前4000-5000年左右的马家浜文化，历经崧泽，良渚，钱山漾等多个时期的演变才进入周代。其中以良渚文化历史最久，也最为知名。\n","permalink":"https://Moondok.github.io/blogs/posts/life/2023_10_22_map/","summary":"","title":"记2023下半年的第一次进城"},{"content":"Greetings! This is CHEN Kaixu (陳開煦) . Currently I am an undergraduate of Tongji Univ.\nThis blog is built to record some technique details during my study. Also , I will record some interesting moments here.\n","permalink":"https://Moondok.github.io/blogs/about/","summary":"Greetings! This is CHEN Kaixu (陳開煦) . Currently I am an undergraduate of Tongji Univ. This blog is built to record some technique details during my study. Also , I will record some interesting moments here.","title":"🙋🏻‍♂️ About"}]